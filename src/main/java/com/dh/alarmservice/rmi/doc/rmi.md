#
#定义
## RMI: 远程方法调用(Remote Method Invocation)，它支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。
## Java RMI: 用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟上中的对象的方法，只不过是允许被远程调用的对象要通过一些标志加以标识。
## rmi.png RMI交互图
## RMI由3个部分构成：

## 第一个是rmiregistry（JDK提供的一个可以独立运行的程序，在bin目录下）
## 第二个是server端的程序，对外提供远程对象
## 第三个是client端的程序，想要调用远程对象的方法。
## 首先，先启动rmiregistry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）。
## 其次，server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的Naming/Context/Registry（下面实例用的Registry）等类的bind或rebind方法将刚才实例化好的实现类注册到rmiregistry上并对外暴露一个名称。
## 最后，client端通过本地的接口和一个已知的名称（即rmiregistry暴露出的名称）再使用RMI提供的Naming/Context/Registry等类的lookup方法从RMIService那拿到实现类。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法了。

## rmi2.png  存根和骨干网的具体通信过程：

## 方法调用从客户对象经存根（stub）、远程引用层（Remote Reference Layer）和传输层（Transport Layer）向下，传递给主机，然后再次经传输层，向上穿过远程调用层和骨干网（Skeleton），到达服务器对象。
## 存根扮演着远程服务器对象的代理的角色，使该对象可被客户激活。
## 远程引用层处理语义、管理单一或多重对象的通信，决定调用是应发往一个服务器还是多个。
## 传输层管理实际的连接，并且追踪可以接受方法调用的远程对象。
## 骨干网完成对服务器对象实际的方法调用，并获取返回值。
## 返回值向下经远程引用层、服务器端的传输层传递回客户端，再向上经传输层和远程调用层返回。最后，存根获得返回值。


# RMI 的优劣
## 1、优势
## 给分布计算的系统设计、编程都带来了极大的方便。只要按照RMI规则设计程序，可以不必再过问在RMI之下的网络细节了，如：TCP和Socket等等。任意两台计算机之间的通讯完全由RMI负责。调用远程计算机上的对象就像本地对象一样方便。
## 2、劣势
## RMI对服务器的IP地址和端口依赖很紧密，但是在开发的时候不知道将来的服务器IP和端口如何，而客户端程序又依赖这个IP和端口。即客户端如何维护服务端地址和动态感知服务端地址变化的问题。
## 另一局限性是，RMI是Java语言的远程调用，两端的程序语言必须是Java实现。











